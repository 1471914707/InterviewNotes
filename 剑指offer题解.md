<!-- GFM-TOC -->
* [第二章 面试需要的基础知识](#第二章-面试需要的基础知识)
    * [3. 数组中重复的数字](#3-数组中重复的数字)
    * [4. 二维数组中的查找](#4-二维数组中的查找)
    * [5. 替换空格](#5-替换空格)
    * [6. 从尾到头打印链表](#6-从尾到头打印链表)
    * [7. 重建二叉树](#7-重建二叉树)
    * [8. 二叉树的下一个结点](#8-二叉树的下一个结点)
    * [9. 用两个栈实现队列](#9-用两个栈实现队列)
    * [10.1 斐波那契数列](#101-斐波那契数列)
    * [10.2 跳台阶](#102-跳台阶)
    * [10.3 变态跳台阶](#103-变态跳台阶)
    * [10.4 矩形覆盖](#104-矩形覆盖)
    * [11. 旋转数组的最小数字](#11-旋转数组的最小数字)
    * [12. 矩阵中的路径](#12-矩阵中的路径)
    * [13. 机器人的运动范围](#13-机器人的运动范围)
    * [15. 二进制中 1 的个数](#15-二进制中-1-的个数)
* [第三章 高质量的代码](#第三章-高质量的代码)
    * [16. 数值的整数次方](#16-数值的整数次方)
    * [19. 正则表达式匹配](#19-正则表达式匹配)
    * [20. 表示数值的字符串](#20-表示数值的字符串)
    * [21. 调整数组顺序使奇数位于偶数前面](#21-调整数组顺序使奇数位于偶数前面)
    * [22. 链表中倒数第 k 个结点](#22-链表中倒数第-k-个结点)
    * [23. 链表中环的入口结点](#23-链表中环的入口结点)
    * [24. 反转链表](#24-反转链表)
    * [25. 合并两个排序的链表](#25-合并两个排序的链表)
    * [26. 树的子结构](#26-树的子结构)
* [第四章 解决面试题的思路](#第四章-解决面试题的思路)
    * [27. 二叉树的镜像](#27-二叉树的镜像)
    * [28. 对称的二叉树](#28-对称的二叉树)
    * [29. 顺时针打印矩阵](#29-顺时针打印矩阵)
    * [30. 包含 min 函数的栈](#30-包含-min-函数的栈)
    * [31. 栈的压入、弹出序列](#31-栈的压入弹出序列)
    * [32. 从上往下打印二叉树](#32-从上往下打印二叉树)
    * [33. 二叉搜索树的后序遍历序列](#33-二叉搜索树的后序遍历序列)
    * [34. 二叉树中和为某一值的路径](#34-二叉树中和为某一值的路径)
    * [35. 复杂链表的复制](#35-复杂链表的复制)
    * [36. 二叉搜索树与双向链表](#36-二叉搜索树与双向链表)
    * [37. 序列化二叉树](#37-序列化二叉树)
    * [38. 字符串的排列](#38-字符串的排列)
* [第五章 优化时间和空间效率](#第五章-优化时间和空间效率)
    * [39. 数组中出现次数超过一半的数字](#39-数组中出现次数超过一半的数字)
    * [40. 最小的 K 个数](#40-最小的-k-个数)
    * [42. 连续子数组的最大和](#42-连续子数组的最大和)
    * [43. 从 1 到 n 整数中 1 出现的次数](#43-从-1-到-n-整数中-1-出现的次数)
    * [45. 把数组排成最小的数](#45-把数组排成最小的数)
    * [49. 丑数](#49-丑数)
    * [50. 第一个只出现一次的字符位置](#50-第一个只出现一次的字符位置)
    * [51. 数组中的逆序对](#51-数组中的逆序对)
    * [52. 两个链表的第一个公共结点](#52-两个链表的第一个公共结点)
* [第六章 面试中的各项能力](#第六章-面试中的各项能力)
    * [53 数字在排序数组中出现的次数](#53-数字在排序数组中出现的次数)
    * [54. 二叉搜索树的第 k 个结点](#54-二叉搜索树的第-k-个结点)
    * [55 二叉树的深度](#55-二叉树的深度)
    * [56. 数组中只出现一次的数字](#56-数组中只出现一次的数字)
    * [57. 和为 S 的两个数字](#57-和为-s-的两个数字)
    * [58.1 翻转单词顺序列](#581-翻转单词顺序列)
    * [58.2 左旋转字符串](#582-左旋转字符串)
    * [61. 扑克牌顺子](#61-扑克牌顺子)
    * [62. 圆圈中最后剩下的数](#62-圆圈中最后剩下的数)
    * [64. 求 1+2+3+...+n](#64-求-123n)
    * [65. 不用加减乘除做加法](#65-不用加减乘除做加法)
    * [66. 构建乘积数组](#66-构建乘积数组)
* [第七章 两个面试案例](#第七章-两个面试案例)
    * [67. 把字符串转换成整数](#67-把字符串转换成整数)
* [未分类](#未分类)
    * [平衡二叉树](#平衡二叉树)
    * [和为 S 的连续正数序列](#和为-s-的连续正数序列)
    * [ 字符流中第一个不重复的字符](#-字符流中第一个不重复的字符)
    * [ 删除链表中重复的结点](#-删除链表中重复的结点)
    * [按之字形顺序打印二叉树](#按之字形顺序打印二叉树)
    * [ 把二叉树打印成多行](#-把二叉树打印成多行)
    * [ 二叉搜索树的第 k 个结点](#-二叉搜索树的第-k-个结点)
    * [滑动窗口的最大值](#滑动窗口的最大值)
<!-- GFM-TOC -->

# 第二章 面试需要的基础知识

## 3. 数组中重复的数字

**题目描述**

在一个长度为 n 的数组里的所有数字都在 0 到 n-1 的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为 7 的数组 {2, 3, 1, 0, 2, 5, 3}，那么对应的输出是第一个重复的数字 2。

**解题思路**

这种数组元素在 [0, n-1] 范围内的问题，可以将值为 i 的元素放到第 i 个位置上。

```java
public boolean duplicate(int numbers[], int length, int[] duplication) {
    for (int i = 0; i < length; i++) {
        while (numbers[i] != i && numbers[i] != numbers[numbers[i]]) {
            swap(numbers, i, numbers[i]);
        }
        if (numbers[i] != i && numbers[i] == numbers[numbers[i]]) {
            duplication[0] = numbers[i];
            return true;
        }
    }
    return false;
}

private void swap(int[] numbers, int i, int j) {
    int t = numbers[i];
    numbers[i] = numbers[j];
    numbers[j] = t;
}
```

## 4. 二维数组中的查找

**题目描述**

在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。

```java
public boolean Find(int target, int [][] array) {
    if (array == null || array.length == 0 || array[0].length == 0) return false;
    int m = array.length, n = array[0].length;
    int row = 0, col = n - 1;
    while (row < m && col >= 0) {
        if (target == array[row][col]) return true;
        else if (target < array[row][col]) col--;
        else row++;
    }
    return false;
}
```

## 5. 替换空格

**题目描述**

请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为 We Are Happy. 则经过替换之后的字符串为 We%20Are%20Happy。

**题目要求**

以 O(1) 的空间复杂度来求解。

```java
public String replaceSpace(StringBuffer str) {
    int n = str.length();
    for (int i = 0; i < n; i++) {
        if (str.charAt(i) == ' ') str.append("  "); // 尾部填充两个
    }

    int idxOfOriginal = n - 1;
    int idxOfNew = str.length() - 1;
    while (idxOfOriginal >= 0 && idxOfNew > idxOfOriginal) {
        if (str.charAt(idxOfOriginal) == ' ') {
            str.setCharAt(idxOfNew--, '0');
            str.setCharAt(idxOfNew--, '2');
            str.setCharAt(idxOfNew--, '%');
        } else {
            str.setCharAt(idxOfNew--, str.charAt(idxOfOriginal));
        }
        idxOfOriginal--;
    }
    return str.toString();
}
```

## 6. 从尾到头打印链表

正向遍历然后调用 Collections.reverse().

```java
public ArrayList<Integer> printListFromTailToHead(ListNode listNode) {
    ArrayList<Integer> ret = new ArrayList<>();
    while (listNode != null) {
        ret.add(listNode.val);
        listNode = listNode.next;
    }
    Collections.reverse(ret);
    return ret;
}
```

递归

```java
public ArrayList<Integer> printListFromTailToHead(ListNode listNode) {
    ArrayList<Integer> ret = new ArrayList<>();
    if(listNode != null) {
        ret.addAll(printListFromTailToHead(listNode.next));
        ret.add(listNode.val);
    }
    return ret;
}
```

不使用库函数，并且不使用递归的迭代实现，利用链表的头插法为逆序的特性。

```java
public ArrayList<Integer> printListFromTailToHead(ListNode listNode) {
    ListNode head = new ListNode(-1); // 头结点
    ListNode cur = listNode;
    while (cur != null) {
        ListNode next = cur.next;
        cur.next = head.next;
        head.next = cur;
        cur = next;
    }
    ArrayList<Integer> ret = new ArrayList<>();
    head = head.next;
    while (head != null) {
        ret.add(head.val);
        head = head.next;
    }
    return ret;
}
```

## 7. 重建二叉树

**题目描述**

输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。

```java
public TreeNode reConstructBinaryTree(int[] pre, int[] in) {
    return reConstructBinaryTree(pre, 0, pre.length - 1, in, 0, in.length - 1);
}
private TreeNode reConstructBinaryTree(int[] pre, int preL, int preR, int[] in, int inL, int inR) {
    if(preL > preR || inL > inR) return null;
    TreeNode root = new TreeNode(pre[preL]);
    if (preL != preR) {
        int idx = inL;
        while (idx <= inR && in[idx] != root.val) idx++;
        int leftTreeLen = idx - inL;
        root.left = reConstructBinaryTree(pre, preL + 1, preL + leftTreeLen, in, inL, inL + leftTreeLen - 1);
        root.right = reConstructBinaryTree(pre, preL + leftTreeLen + 1, preR, in, inL + leftTreeLen + 1, inR);
    }
    return root;
}
```

## 8. 二叉树的下一个结点

**题目描述**

给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。

```java
public TreeLinkNode GetNext(TreeLinkNode pNode) {
    if (pNode == null) return null;
    if (pNode.right != null) {
        pNode = pNode.right;
        while (pNode.left != null) pNode = pNode.left;
        return pNode;
    } else {
        TreeLinkNode parent = pNode.next;
        while (parent != null) {
            if (parent.left == pNode) return parent;
            pNode = pNode.next;
            parent = pNode.next;
        }
    }
    return null;
}
```

## 9. 用两个栈实现队列

```java
Stack<Integer> stack1 = new Stack<Integer>();
Stack<Integer> stack2 = new Stack<Integer>();

public void push(int node) {
    stack1.push(node);
}

public int pop() {
    if (stack2.isEmpty()) {
        while (!stack1.isEmpty()) {
            stack2.push(stack1.pop());
        }
    }
    return stack2.pop();
}
```

## 10.1 斐波那契数列

```java
private int[] fib = new int[40];

public Solution() {
    fib[1] = 1;
    fib[2] = 2;
    for (int i = 2; i < fib.length; i++) {
        fib[i] = fib[i - 1] + fib[i - 2];
    }
}

public int Fibonacci(int n) {
    return fib[n];
}
```

## 10.2 跳台阶

```java
public int JumpFloor(int target) {
    if (target == 1) return 1;
    int[] dp = new int[target];
    dp[0] = 1;
    dp[1] = 2;
    for (int i = 2; i < dp.length; i++) {
        dp[i] = dp[i - 1] + dp[i - 2];
    }
    return dp[target - 1];
}
```

## 10.3 变态跳台阶

```java
public int JumpFloorII(int target) {
    int[] dp = new int[target];
    Arrays.fill(dp, 1);
    for (int i = 1; i < target; i++) {
        for (int j = 0; j < i; j++) {
            dp[i] += dp[j];
        }
    }
    return dp[target - 1];
}
```

## 10.4 矩形覆盖

**题目描述**

我们可以用 2\*1 的小矩形横着或者竖着去覆盖更大的矩形。请问用 n 个 2\*1 的小矩形无重叠地覆盖一个 2\*n 的大矩形，总共有多少种方法？

```java
public int RectCover(int target) {
    if (target <= 2) return target;
    return RectCover(target - 1) + RectCover(target - 2);
}
```


## 11. 旋转数组的最小数字

**题目描述**

把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组 {3, 4, 5, 1, 2} 为 {1, 2, 3, 4, 5} 的一个旋转，该数组的最小值为 1。 NOTE：给出的所有元素都大于 0，若数组大小为 0，请返回 0。

```java
public int minNumberInRotateArray(int[] array) {
    if (array.length == 0) return 0;
    for (int i = 0; i < array.length - 1; i++) {
        if (array[i] > array[i + 1]) return array[i + 1];
    }
    return 0;
}
```

## 12. 矩阵中的路径

**题目描述**

请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。 例如 a b c e s f c s a d e e 矩阵中包含一条字符串 "bcced" 的路径，但是矩阵中不包含 "abcb" 路径，因为字符串的第一个字符 b 占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。

```java
private int[][] next = {{0, -1}, {0, 1}, {-1, 0}, {1, 0}};

public boolean hasPath(char[] matrix, int rows, int cols, char[] str) {
    if (rows == 0 || cols == 0) return false;
    char[][] m = new char[rows][cols];
    for (int i = 0, idx = 0; i < rows; i++) {
        for (int j = 0; j < cols; j++) {
            m[i][j] = matrix[idx++];
        }
    }

    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < cols; j++) {
            if (backtracking(m, rows, cols, str, new boolean[rows][cols], 0, i, j)) return true;
        }
    }
    return false;
}

private boolean backtracking(char[][] m, int rows, int cols, char[] str, boolean[][] used, int path, int r, int c) {
    if (path == str.length) return true;
    if (r < 0 || r >= rows || c < 0 || c >= cols) return false;
    if (m[r][c] != str[path]) return false;
    if (used[r][c]) return false;
    used[r][c] = true;
    for (int i = 0; i < next.length; i++) {
        if (backtracking(m, rows, cols, str, used, path + 1, r + next[i][0], c + next[i][1])) return true;
    }
    used[r][c] = false;
    return false;
}
```

## 13. 机器人的运动范围

**题目描述**

地上有一个 m 行和 n 列的方格。一个机器人从坐标 0, 0 的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于 k 的格子。 例如，当 k 为 18 时，机器人能够进入方格（35, 37），因为 3+5+3+7 = 18。但是，它不能进入方格（35, 38），因为 3+5+3+8 = 19。请问该机器人能够达到多少个格子？

```java
private int cnt = 0;
private int[][] next = {{0, -1}, {0, 1}, {-1, 0}, {1, 0}};
private int[][] digitSum;

public int movingCount(int threshold, int rows, int cols) {
    initDigitSum(rows, cols);
    dfs(new boolean[rows][cols], threshold, rows, cols, 0, 0);
    return cnt;
}

private void dfs(boolean[][] visited, int threshold, int rows, int cols, int r, int c) {
    if (r < 0 || r >= rows || c < 0 || c >= cols) return;
    if (visited[r][c]) return;
    visited[r][c] = true;
    if (this.digitSum[r][c] > threshold) return;
    this.cnt++;
    for (int i = 0; i < this.next.length; i++) {
        dfs(visited, threshold, rows, cols, r + next[i][0], c + next[i][1]);
    }
}

private void initDigitSum(int rows, int cols) {
    int[] digitSumOne = new int[Math.max(rows, cols)];
    for (int i = 0; i < digitSumOne.length; i++) {
        int n = i;
        while (n > 0) {
            digitSumOne[i] += n % 10;
            n /= 10;
        }
    }
    this.digitSum = new int[rows][cols];
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < cols; j++) {
            this.digitSum[i][j] = digitSumOne[i] + digitSumOne[j];
        }
    }
}
```

## 15. 二进制中 1 的个数

```java
public int NumberOf1(int n) {
    return Integer.bitCount(n);
}
```

n&(n-1) 该位运算是去除 n 的位级表示中最低的那一位。例如对于二进制表示 10110100，减去 1 得到 10110011，这两个数相与得到 10110000。

```java
public int NumberOf1(int n) {
    int cnt = 0;
    while (n != 0) {
        cnt++;
        n &= (n - 1);
    }
    return cnt;
}

```

# 第三章 高质量的代码

## 16. 数值的整数次方

```java
public double Power(double base, int exponent) {
    if (exponent == 0) return 1;
    if (exponent == 1) return base;
    boolean isNegative = false;
    if (exponent < 0) {
        exponent = -exponent;
        isNegative = true;
    }
    double pow = Power(base * base, exponent / 2);
    if (exponent % 2 != 0) pow = pow * base;
    return isNegative ? 1 / pow : pow;
}
```

## 19. 正则表达式匹配

**题目描述**

请实现一个函数用来匹配包括 '.' 和 '\*' 的正则表达式。模式中的字符 '.' 表示任意一个字符，而 '\*' 表示它前面的字符可以出现任意次（包含 0 次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串 "aaa" 与模式 "a.a" 和 "ab\*ac\*a" 匹配，但是与 "aa.a" 和 "ab\*a" 均不匹配

```java
public boolean match(char[] str, char[] pattern) {
    int n = str.length, m = pattern.length;
    boolean[][] dp = new boolean[n + 1][m + 1];
    dp[0][0] = true;
    for (int i = 1; i <= m; i++) {
        if (pattern[i - 1] == '*') dp[0][i] = dp[0][i - 2];
    }
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            if (str[i - 1] == pattern[j - 1] || pattern[j - 1] == '.') dp[i][j] = dp[i - 1][j - 1];
            else if (pattern[j - 1] == '*') {
                if (pattern[j - 2] != str[i - 1] && pattern[j - 2] != '.') dp[i][j] = dp[i][j - 2];
                else dp[i][j] = dp[i][j - 1] || dp[i][j - 2] || dp[i - 1][j];
            }
        }
    }
    return dp[n][m];
}
```

## 20. 表示数值的字符串

```java
public boolean isNumeric(char[] str) {
    String string = String.valueOf(str);
    return string.matches("[\\+-]?[0-9]*(\\.[0-9]*)?([eE][\\+-]?[0-9]+)?");
}
```

## 21. 调整数组顺序使奇数位于偶数前面

时间复杂度 : O(n<sup>2</sup>)
空间复杂度 : O(1)

```java
public void reOrderArray(int[] array) {
    int n = array.length;
    for (int i = 0; i < n; i++) {
        if (array[i] % 2 == 0) {
            int nextOddIdx = i + 1;
            while (nextOddIdx < n && array[nextOddIdx] % 2 == 0) nextOddIdx++;
            if (nextOddIdx == n) break;
            int nextOddVal = array[nextOddIdx];
            for (int j = nextOddIdx; j > i; j--) {
                array[j] = array[j - 1];
            }
            array[i] = nextOddVal;
        }
    }
}
```

## 22. 链表中倒数第 k 个结点

```java
public ListNode FindKthToTail(ListNode head, int k) {
    if (head == null) return null;
    ListNode fast, slow;
    fast = slow = head;
    while (fast != null && k-- > 0) fast = fast.next;
    if (k > 0) return null;
    while (fast != null) {
        fast = fast.next;
        slow = slow.next;
    }
    return slow;
}
```

时间复杂度 : O(n)
空间复杂度 : O(n)

```java
public void reOrderArray(int[] array) {
    int oddCnt = 0;
    for (int num : array) if (num % 2 == 1) oddCnt++;
    int[] copy = array.clone();
    int i = 0, j = oddCnt;
    for (int num : copy) {
        if (num % 2 == 1) array[i++] = num;
        else array[j++] = num;
    }
}
```

## 23. 链表中环的入口结点

```java
public ListNode EntryNodeOfLoop(ListNode pHead) {
    if (pHead == null) return null;
    ListNode slow = pHead, fast = pHead;
    while (fast != null && fast.next != null) {
        fast = fast.next.next;
        slow = slow.next;
        if (slow == fast) {
            fast = pHead;
            while (slow != fast) {
                slow = slow.next;
                fast = fast.next;
            }
            return slow;
        }
    }
    return null;
}
```

## 24. 反转链表

```java
public ListNode ReverseList(ListNode head) {
    ListNode newList = new ListNode(-1);
    while (head != null) {
        ListNode next = head.next;
        head.next = newList.next;
        newList.next = head;
        head = next;
    }
    return newList.next;
}
```

## 25. 合并两个排序的链表

```java
public ListNode Merge(ListNode list1, ListNode list2) {
    ListNode head = new ListNode(-1);
    ListNode cur = head;
    while (list1 != null && list2 != null) {
        if (list1.val < list2.val) {
            cur.next = list1;
            list1 = list1.next;
        } else {
            cur.next = list2;
            list2 = list2.next;
        }
        cur = cur.next;
    }
    if (list1 != null) cur.next = list1;
    if (list2 != null) cur.next = list2;
    return head.next;
}
```

## 26. 树的子结构

```java
public boolean HasSubtree(TreeNode root1, TreeNode root2) {
    if (root1 == null || root2 == null) return false;
    return isSubtree(root1, root2) || HasSubtree(root1.left, root2) || HasSubtree(root1.right, root2);
}

private boolean isSubtree(TreeNode root1, TreeNode root2) {
    if (root1 == null && root2 == null) return true;
    if (root1 == null) return false;
    if (root2 == null) return true;
    if (root1.val != root2.val) return false;
    return isSubtree(root1.left, root2.left) && isSubtree(root1.right, root2.right);
}
```

# 第四章 解决面试题的思路

## 27. 二叉树的镜像

```java
public void Mirror(TreeNode root) {
    if (root == null) return;
    TreeNode t = root.left;
    root.left = root.right;
    root.right = t;
    Mirror(root.left);
    Mirror(root.right);
}
```

## 28. 对称的二叉树

```java
boolean isSymmetrical(TreeNode pRoot) {
    if (pRoot == null) return true;
    return isSymmetrical(pRoot.left, pRoot.right);
}

boolean isSymmetrical(TreeNode t1, TreeNode t2) {
    if (t1 == null && t2 == null) return true;
    if (t1 == null || t2 == null) return false;
    if (t1.val != t2.val) return false;
    return isSymmetrical(t1.left, t2.right) && isSymmetrical(t1.right, t2.left);
}
```

## 29. 顺时针打印矩阵

```java
public ArrayList<Integer> printMatrix(int[][] matrix) {
    ArrayList<Integer> ret = new ArrayList<>();
    int r1 = 0, r2 = matrix.length - 1, c1 = 0, c2 = matrix[0].length - 1;
    while (r1 <= r2 && c1 <= c2) {
        for (int i = c1; i <= c2; i++) ret.add(matrix[r1][i]);
        for (int i = r1 + 1; i <= r2; i++) ret.add(matrix[i][c2]);
        if (r1 != r2) for (int i = c2 - 1; i >= c1; i--) ret.add(matrix[r2][i]);
        if (c1 != c2) for (int i = r2 - 1; i > r1; i--) ret.add(matrix[i][c1]);
        r1++; r2--; c1++; c2--;
    }
    return ret;
}
```

## 30. 包含 min 函数的栈

```java
private Stack<Integer> stack = new Stack<>();
private Stack<Integer> minStack = new Stack<>();
private int min = Integer.MAX_VALUE;

public void push(int node) {
    stack.push(node);
    if (min > node) min = node;
    minStack.push(min);
}

public void pop() {
    stack.pop();
    minStack.pop();
    min = minStack.peek();
}

public int top() {
    return stack.peek();
}

public int min() {
    return minStack.peek();
}
```

## 31. 栈的压入、弹出序列

```java
public boolean IsPopOrder(int[] pushA, int[] popA) {
    int n = pushA.length;
    Stack<Integer> stack = new Stack<>();
    for (int i = 0, j = 0; i < n; i++) {
        stack.push(pushA[i]);
        while (j < n && stack.peek() == popA[j]) {
            stack.pop();
            j++;
        }
    }
    return stack.isEmpty();
}
```

## 32. 从上往下打印二叉树

```java
public ArrayList<Integer> PrintFromTopToBottom(TreeNode root) {
    Queue<TreeNode> queue = new LinkedList<>();
    ArrayList<Integer> ret = new ArrayList<>();
    if (root == null) return ret;
    queue.add(root);
    while (!queue.isEmpty()) {
        int cnt = queue.size();
        for (int i = 0; i < cnt; i++) {
            TreeNode t = queue.poll();
            if (t.left != null) queue.add(t.left);
            if (t.right != null) queue.add(t.right);
            ret.add(t.val);
        }
    }
    return ret;
}
```

## 33. 二叉搜索树的后序遍历序列

```java
public boolean VerifySquenceOfBST(int[] sequence) {
    if (sequence.length == 0) return false;
    return verify(sequence, 0, sequence.length - 1);
}

private boolean verify(int[] sequence, int start, int end) {
    if (end - start <= 1) return true;
    int rootVal = sequence[end];
    int cutIdx = start;
    while (cutIdx < end) {
        if (sequence[cutIdx] > rootVal) break;
        cutIdx++;
    }
    for (int i = cutIdx + 1; i < end; i++) {
        if (sequence[i] < rootVal) return false;
    }
    return verify(sequence, start, cutIdx - 1) && verify(sequence, cutIdx, end - 1);
}
```

## 34. 二叉树中和为某一值的路径

```java
private ArrayList<ArrayList<Integer>> ret = new ArrayList<>();

public ArrayList<ArrayList<Integer>> FindPath(TreeNode root, int target) {
    dfs(root, target, 0, new ArrayList<>());
    return ret;
}

private void dfs(TreeNode node, int target, int curSum, ArrayList<Integer> path) {
    if (node == null) return;
    curSum += node.val;
    path.add(node.val);
    if (curSum == target && node.left == null && node.right == null) {
        ret.add(new ArrayList(path));
    } else {
        dfs(node.left, target, curSum, path);
        dfs(node.right, target, curSum, path);
    }
    path.remove(path.size() - 1);
}
```

## 35. 复杂链表的复制

第一步，在每个节点的后面插入复制的节点。

![](https://github.com/00000H/notes/blob/master/pics/f8b12555-967b-423d-a84e-bc9eff104b8b.jpg)

第二步，对复制节点的 random 链接进行赋值。

![](https://github.com/00000H/notes/blob/master/pics/7b877a2a-8fd1-40d8-a34c-c445827300b8.jpg)

第三步，拆分。

![](https://github.com/00000H/notes/blob/master/pics/b2b6253c-c701-4b30-aff4-bc3c713542a7.jpg)


```java
public RandomListNode Clone(RandomListNode pHead) {
    if (pHead == null) return null;
    // 插入新节点
    RandomListNode cur = pHead;
    while (cur != null) {
        RandomListNode node = new RandomListNode(cur.label);
        node.next = cur.next;
        cur.next = node;
        cur = node.next;
    }
    // 建立 random 链接
    cur = pHead;
    while (cur != null) {
        RandomListNode clone = cur.next;
        if (cur.random != null) {
            clone.random = cur.random.next;
        }
        cur = clone.next;
    }
    // 拆分
    RandomListNode pCloneHead = pHead.next;
    cur = pHead;
    while (cur.next != null) {
        RandomListNode t = cur.next;
        cur.next = t.next;
        cur = t;
    }
    return pCloneHead;
}
```

## 36. 二叉搜索树与双向链表

```java
private TreeNode pre = null;
public TreeNode Convert(TreeNode pRootOfTree) {
    if(pRootOfTree == null) return null;
    inOrder(pRootOfTree);
    while(pRootOfTree.left != null) pRootOfTree = pRootOfTree.left;
    return pRootOfTree;
}

private void inOrder(TreeNode node) {
    if(node == null) return;
    inOrder(node.left);
    node.left = pre;
    if(pre != null) pre.right = node;
    pre = node;
    inOrder(node.right);
}
```

## 37. 序列化二叉树

```java
private String serizeString = "";

String Serialize(TreeNode root) {
    if (root == null) return "#";
    return root.val + " " + Serialize(root.left) + " "
        + Serialize(root.right);
}

TreeNode Deserialize(String str) {
    this.serizeString = str;
    return Deserialize();
}

private TreeNode Deserialize() {
    if (this.serizeString.length() == 0) return null;
    int idx = this.serizeString.indexOf(" ");
    if (idx == -1) return null;
    String sub = this.serizeString.substring(0, idx);
    this.serizeString = this.serizeString.substring(idx + 1);
    if (sub.equals("#")) {
        return null;
    }
    int val = Integer.valueOf(sub);
    TreeNode t = new TreeNode(val);
    t.left = Deserialize();
    t.right = Deserialize();
    return t;
}
```

## 38. 字符串的排列

```java
private ArrayList<String> ret = new ArrayList<>();

public ArrayList<String> Permutation(String str) {
    if (str.length() == 0) return new ArrayList<>();
    char[] chars = str.toCharArray();
    Arrays.sort(chars);
    backtracking(chars, new boolean[chars.length], "");
    return ret;
}

private void backtracking(char[] chars, boolean[] used, String s) {
    if (s.length() == chars.length) {
        ret.add(s);
        return;
    }
    for (int i = 0; i < chars.length; i++) {
        if (used[i]) continue;
        if (i != 0 && chars[i] == chars[i - 1] && !used[i - 1]) continue; // 保证不重复
        used[i] = true;
        backtracking(chars, used, s + chars[i]);
        used[i] = false;
    }
}
```

# 第五章 优化时间和空间效率

## 39. 数组中出现次数超过一半的数字

```java
public int MoreThanHalfNum_Solution(int[] array) {
    int cnt = 1, num = array[0];
    for (int i = 1; i < array.length; i++) {
        if (array[i] == num) cnt++;
        else cnt--;
        if (cnt == 0) {
            num = array[i];
            cnt = 1;
        }
    }
    cnt = 0;
    for (int i = 0; i < array.length; i++) {
        if (num == array[i]) cnt++;
    }
    return cnt > array.length / 2 ? num : 0;
}
```


## 40. 最小的 K 个数

构建大小为 k 的小顶堆。

时间复杂度：O(nlgk)
空间复杂度：O(k)

```java
public ArrayList<Integer> GetLeastNumbers_Solution(int[] input, int k) {
    if (k > input.length || k <= 0) return new ArrayList<>();
    PriorityQueue<Integer> pq = new PriorityQueue<>((o1, o2) -> o2 - o1);
    for (int num : input) {
        pq.add(num);
        if (pq.size() > k) {
            pq.poll();
        }
    }
    ArrayList<Integer> ret = new ArrayList<>(pq);
    return ret;
}
```

利用快速选择

时间复杂度：O(n)
空间复杂度：O(1)

```java
public ArrayList<Integer> GetLeastNumbers_Solution(int[] input, int k) {
    if (k > input.length || k <= 0) return new ArrayList<>();
    int kthSmallest = findKthSmallest(input, k - 1);
    ArrayList<Integer> ret = new ArrayList<>();
    for (int num : input) {
        if(num <= kthSmallest && ret.size() < k) ret.add(num);
    }
    return ret;
}

public int findKthSmallest(int[] nums, int k) {
    int lo = 0;
    int hi = nums.length - 1;
    while (lo < hi) {
        int j = partition(nums, lo, hi);
        if (j < k) {
            lo = j + 1;
        } else if (j > k) {
            hi = j - 1;
        } else {
            break;
        }
    }
    return nums[k];
}

private int partition(int[] a, int lo, int hi) {
    int i = lo;
    int j = hi + 1;
    while (true) {
        while (i < hi && less(a[++i], a[lo])) ;
        while (j > lo && less(a[lo], a[--j])) ;
        if (i >= j) {
            break;
        }
        exch(a, i, j);
    }
    exch(a, lo, j);
    return j;
}

private void exch(int[] a, int i, int j) {
    final int tmp = a[i];
    a[i] = a[j];
    a[j] = tmp;
}

private boolean less(int v, int w) {
    return v < w;
}
```

## 42. 连续子数组的最大和

```java
public int FindGreatestSumOfSubArray(int[] array) {
    if(array.length == 0) return 0;
    int ret = Integer.MIN_VALUE;
    int sum = 0;
    for(int num : array) {
        if(sum <= 0) sum = num;
        else sum += num;
        ret = Math.max(ret, sum);
    }
    return ret;
}
```

## 43. 从 1 到 n 整数中 1 出现的次数

解题参考：[Leetcode : 233. Number of Digit One](https://leetcode.com/problems/number-of-digit-one/discuss/64381/4+-lines-O(log-n)-C++JavaPython)

```java
public int NumberOf1Between1AndN_Solution(int n) {
    int cnt = 0;
    for (int m = 1; m <= n; m *= 10) {
        int a = n / m, b = n % m;
        cnt += (a + 8) / 10 * m + (a % 10 == 1 ? b + 1 : 0);
    }
    return cnt;
}
```

## 45. 把数组排成最小的数

```java
public String PrintMinNumber(int[] numbers) {
    int n = numbers.length;
    String[] nums = new String[n];
    for (int i = 0; i < n; i++) nums[i] = numbers[i] + "";
    Arrays.sort(nums, (s1, s2) -> (s1 + s2).compareTo(s2 + s1));
    String ret = "";
    for (String str : nums) ret += str;
    return ret;
}
```

## 49. 丑数

```java
public int GetUglyNumber_Solution(int index) {
    if (index <= 6) return index;
    int i2 = 0, i3 = 0, i5 = 0;
    int cnt = 1;
    int[] dp = new int[index];
    dp[0] = 1;
    while (cnt < index) {
        int n2 = dp[i2] * 2, n3 = dp[i3] * 3, n5 = dp[i5] * 5;
        int tmp = Math.min(n2, Math.min(n3, n5));
        dp[cnt++] = tmp;
        if (tmp == n2) i2++;
        if (tmp == n3) i3++;
        if (tmp == n5) i5++;
    }
    return dp[index - 1];
}
```

## 50. 第一个只出现一次的字符位置

```java
public int FirstNotRepeatingChar(String str) {
    int[] cnts = new int[256];
    for (int i = 0; i < str.length(); i++) cnts[str.charAt(i)]++;
    for (int i = 0; i < str.length(); i++) if (cnts[str.charAt(i)] == 1) return i;
    return -1;
}
```

## 51. 数组中的逆序对

```java
private long cnt = 0;

public int InversePairs(int[] array) {
    mergeSortUp2Down(array, 0, array.length - 1);
    return (int) (cnt % 1000000007);
}

private void mergeSortUp2Down(int[] a, int start, int end) {
    if (end - start < 1) return;
    int mid = start + (end - start) / 2;
    mergeSortUp2Down(a, start, mid);
    mergeSortUp2Down(a, mid + 1, end);
    merge(a, start, mid, end);
}

private void merge(int[] a, int start, int mid, int end) {
    int[] tmp = new int[end - start + 1];
    int i = start, j = mid + 1, k = 0;
    while (i <= mid || j <= end) {
        if (i > mid) tmp[k] = a[j++];
        else if (j > end) tmp[k] = a[i++];
        else if (a[i] < a[j]) tmp[k] = a[i++];
        else {
            tmp[k] = a[j++];
            this.cnt += mid - i + 1; // a[i] > a[j] ，说明 a[i...mid] 都大于 a[j]
        }
        k++;
    }

    for (k = 0; k < tmp.length; k++) {
        a[start + k] = tmp[k];
    }
}
```

## 52. 两个链表的第一个公共结点

```java
public ListNode FindFirstCommonNode(ListNode pHead1, ListNode pHead2) {
    ListNode l1 = pHead1, l2 = pHead2;
    while (l1 != l2) {
        if (l1 == null) l1 = pHead2;
        else l1 = l1.next;
        if (l2 == null) l2 = pHead1;
        else l2 = l2.next;
    }
    return l1;
}
```

# 第六章 面试中的各项能力

## 53 数字在排序数组中出现的次数

```java
public int GetNumberOfK(int[] array, int k) {
    int l = 0, h = array.length - 1;
    while (l <= h) {
        int m = l + (h - l) / 2;
        if (array[m] >= k) h = m - 1;
        else l = m + 1;
    }
    int cnt = 0;
    while (l < array.length && array[l++] == k) cnt++;
    return cnt;
}
```

## 54. 二叉搜索树的第 k 个结点

```java
TreeNode ret;
int cnt = 0;

TreeNode KthNode(TreeNode pRoot, int k) {
    inorder(pRoot, k);
    return ret;
}

private void inorder(TreeNode root, int k) {
    if (root == null) return;
    if (cnt > k) return;
    inorder(root.left, k);
    cnt++;
    if (cnt == k) ret = root;
    inorder(root.right, k);
}
```

## 55 二叉树的深度

```java
public int TreeDepth(TreeNode root) {
    if (root == null) return 0;
    return 1 + Math.max(TreeDepth(root.left), TreeDepth(root.right));
}
```

## 56. 数组中只出现一次的数字

两个不相等的元素在位级表示上必定会有一位存在不同。

将数组的所有元素异或得到的结果为不存在重复的两个元素异或的结果。

diff &= -diff 得到出 diff 最右侧不为 0 的位，也就是不存在重复的两个元素在位级表示上最右侧不同的那一位，利用这一位就可以将两个元素区分开来。

```java
public void FindNumsAppearOnce(int[] array, int num1[], int num2[]) {
    int diff = 0;
    for (int num : array) diff ^= num;
    // 得到最右一位
    diff &= -diff;
    for (int num : array) {
        if ((num & diff) == 0) num1[0] ^= num;
        else num2[0] ^= num;
    }
}
```

## 57. 和为 S 的两个数字

```java
public ArrayList<Integer> FindNumbersWithSum(int[] array, int sum) {
    int i = 0, j = array.length - 1;
    while (i < j) {
        int cur = array[i] + array[j];
        if (cur == sum) return new ArrayList<Integer>(Arrays.asList(array[i], array[j]));
        else if (cur < sum) i++;
        else j--;
    }
    return new ArrayList<Integer>();
}
```

## 58.1 翻转单词顺序列

```java
public String ReverseSentence(String str) {
    if (str.length() == 0) return str;
    int n = str.length();
    char[] chars = str.toCharArray();
    int start = 0, end = 0;
    while (end <= n) {
        if (end == n || chars[end] == ' ') {
            reverse(chars, start, end - 1);
            start = end + 1;
        }
        end++;
    }
    reverse(chars, 0, n - 1);
    return new String(chars);
}

private void reverse(char[] c, int start, int end) {
    while (start < end) {
        char t = c[start];
        c[start] = c[end];
        c[end] = t;
        start++;
        end--;
    }
}
```

## 58.2 左旋转字符串

```java
public String LeftRotateString(String str, int n) {
    if (str.length() == 0) return "";
    char[] c = str.toCharArray();
    reverse(c, 0, n - 1);
    reverse(c, n, c.length - 1);
    reverse(c, 0, c.length - 1);
    return new String(c);
}

private void reverse(char[] c, int i, int j) {
    while (i < j) {
        char t = c[i];
        c[i] = c[j];
        c[j] = t;
        i++;
        j--;
    }
}
```

## 61. 扑克牌顺子

```java
public boolean isContinuous(int[] numbers) {
    if (numbers.length < 5) return false;
    Arrays.sort(numbers);
    int cnt = 0;
    for (int num : numbers) if (num == 0) cnt++;
    for (int i = cnt; i < numbers.length - 1; i++) {
        if (numbers[i + 1] == numbers[i]) return false;
        int cut = numbers[i + 1] - numbers[i] - 1;
        if (cut > cnt) return false;
        cnt -= cut;
    }
    return true;
}
```

## 62. 圆圈中最后剩下的数

**题目描述**

让小朋友们围成一个大圈。然后 , 他随机指定一个数 m, 让编号为 0 的小朋友开始报数。每次喊到 m-1 的那个小朋友要出列唱首歌 , 然后可以在礼品箱中任意的挑选礼物 , 并且不再回到圈中 , 从他的下一个小朋友开始 , 继续 0...m-1 报数 .... 这样下去 .... 直到剩下最后一个小朋友 , 可以不用表演 ,

**解题思路**

约瑟夫环

```java
public int LastRemaining_Solution(int n, int m) {
    if (n == 0) return -1;
    if (n == 1) return 0;
    return (LastRemaining_Solution(n - 1, m) + m) % n;
}
```

## 64. 求 1+2+3+...+n

```java
public int Sum_Solution(int n) {
    if(n == 0) return 0;
    return n + Sum_Solution(n - 1);
}
```

## 65. 不用加减乘除做加法

a ^ b 表示没有考虑进位的情况下两数的和，(a & b) << 1 就是进位。递归会终止的原因是 (a & b) << 1 最右边会多一个 0，那么继续递归，进位最右边的 0 会慢慢增多，最后进位会变为 0，递归终止。

```java
public int Add(int num1, int num2) {
    if(num2 == 0) return num1;
    return Add(num1 ^ num2, (num1 & num2) << 1);
}
```

## 66. 构建乘积数组

```java
public int[] multiply(int[] A) {
    int n = A.length;
    int[][] dp = new int[n][n];
    for (int i = 0; i < n; i++) {
        dp[i][i] = A[i];
    }
    for (int i = 0; i < n; i++) {
        for (int j = i + 1; j < n; j++) {
            dp[i][j] = dp[i][j - 1] * A[j];
        }
    }

    int[] B = new int[n];
    Arrays.fill(B, 1);
    for (int i = 0; i < n; i++) {
        if (i != 0) B[i] *= dp[0][i - 1];
        if (i != n - 1) B[i] *= dp[i + 1][n - 1];
    }
    return B;
}
```

# 第七章 两个面试案例

## 67. 把字符串转换成整数

```java
public int StrToInt(String str) {
    if (str.length() == 0) return 0;
    char[] chars = str.toCharArray();
    boolean isNegative = chars[0] == '-';
    int ret = 0;
    for (int i = 0; i < chars.length; i++) {
        if (i == 0 && (chars[i] == '+' || chars[i] == '-')) continue;
        if (chars[i] < '0' || chars[i] > '9') return 0;
        ret = ret * 10 + (chars[i] - '0');
    }
    return isNegative ? -ret : ret;
}
```

# 未分类

## 平衡二叉树

```java
private boolean isBalanced = true;

public boolean IsBalanced_Solution(TreeNode root) {
    height(root);
    return isBalanced;
}

private int height(TreeNode root) {
    if (root == null) return 0;
    int left = height(root.left);
    int right = height(root.right);
    if (Math.abs(left - right) > 1) isBalanced = false;
    return 1 + Math.max(left, right);
}
```

## 和为 S 的连续正数序列

```java
public ArrayList<ArrayList<Integer>> FindContinuousSequence(int sum) {
    ArrayList<ArrayList<Integer>> ret = new ArrayList<>();
    int start = 1, end = 2;
    int mid = sum / 2;
    int curSum = 3;
    while (start <= mid && end < sum) {
        if (curSum > sum) {
            curSum -= start;
            start++;
        } else if (curSum < sum) {
            end++;
            curSum += end;
        } else {
            ArrayList<Integer> list = new ArrayList<>();
            for (int i = start; i <= end; i++) {
                list.add(i);
            }
            ret.add(list);
            curSum -= start;
            start++;
            end++;
            curSum += end;
        }
    }
    return ret;
}
```

##  字符流中第一个不重复的字符

```java
//Insert one char from stringstream
private int[] cnts = new int[256];
private Queue<Character> queue = new LinkedList<>();

public void Insert(char ch) {
    cnts[ch]++;
    queue.add(ch);
    while (!queue.isEmpty() && cnts[queue.peek()] > 1) {
        queue.poll();
    }
}

//return the first appearence once char in current stringstream
public char FirstAppearingOnce() {
    if (queue.isEmpty()) return '#';
    return queue.peek();
}
```



##  删除链表中重复的结点

```java
public ListNode deleteDuplication(ListNode pHead) {
    if (pHead == null) return null;
    if (pHead.next == null) return pHead;
    if (pHead.val == pHead.next.val) {
        ListNode next = pHead.next;
        while (next != null && pHead.val == next.val) {
            next = next.next;
        }
        return deleteDuplication(next);
    } else {
        pHead.next = deleteDuplication(pHead.next);
        return pHead;
    }
}
```

## 按之字形顺序打印二叉树

```java
public ArrayList<ArrayList<Integer>> Print(TreeNode pRoot) {
    ArrayList<ArrayList<Integer>> ret = new ArrayList<>();
    if (pRoot == null) return ret;
    Queue<TreeNode> queue = new LinkedList<>();
    queue.add(pRoot);
    boolean reverse = false;
    while (!queue.isEmpty()) {
        int cnt = queue.size();
        ArrayList<Integer> list = new ArrayList<>();
        for (int i = 0; i < cnt; i++) {
            TreeNode node = queue.poll();
            list.add(node.val);
            if (node.left != null) queue.add(node.left);
            if (node.right != null) queue.add(node.right);
        }
        if (reverse) {
            Collections.reverse(list);
            reverse = false;
        } else {
            reverse = true;
        }
        ret.add(list);
    }
    return ret;
}
```

##  把二叉树打印成多行

```java
ArrayList<ArrayList<Integer>> Print(TreeNode pRoot) {
    ArrayList<ArrayList<Integer>> ret = new ArrayList<>();
    if (pRoot == null) return ret;
    Queue<TreeNode> queue = new LinkedList<>();
    queue.add(pRoot);
    while (!queue.isEmpty()) {
        int cnt = queue.size();
        ArrayList<Integer> list = new ArrayList<>();
        for (int i = 0; i < cnt; i++) {
            TreeNode node = queue.poll();
            list.add(node.val);
            if (node.left != null) queue.add(node.left);
            if (node.right != null) queue.add(node.right);
        }
        ret.add(list);
    }
    return ret;
}
```

##  二叉搜索树的第 k 个结点

```java
TreeNode ret;
int cnt = 0;
TreeNode KthNode(TreeNode pRoot, int k)
{
    inorder(pRoot, k);
    return ret;
}

private void inorder(TreeNode root, int k) {
    if(root == null) return;
    if(cnt > k) return;
    inorder(root.left, k);
    cnt++;
    if(cnt == k) ret = root;
    inorder(root.right, k);
}
```

## 滑动窗口的最大值

```java
public ArrayList<Integer> maxInWindows(int[] num, int size) {
    ArrayList<Integer> ret = new ArrayList<>();
    PriorityQueue<Integer> heap = new PriorityQueue<Integer>((o1, o2) -> o2 - o1);
    if (size > num.length || size < 1) return ret;
    for (int i = 0; i < size; i++) heap.add(num[i]);
    ret.add(heap.peek());
    for (int i = 1; i + size - 1 < num.length; i++) {
        heap.remove(num[i - 1]);
        heap.add(num[i + size - 1]);
        ret.add(heap.peek());
    }
    return ret;
}
```

